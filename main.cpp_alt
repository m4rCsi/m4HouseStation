/************************************************************************/
/*                                                                      */
/************************************************************************/
#include	"Arduino.h"
#include	"SD.h"
#include	"Ethernet.h"
#include	<Wire.h>
#include	"RTClib.h"
#include	<avr/io.h >
#include	<avr/interrupt.h>
#include	"Flash.h"
#include	"TinyWebServer.h"

void		setup();
void		loop();

// On the Ethernet Shield, CS is pin 4. Note that even if it's not
// used as the CS pin, the hardware CS pin (10 on most Arduino boards,
// 53 on the Mega) must be left as an output or the SD library
// functions will not work.
const int chipSelect = 4;

// Enter a MAC address and IP address for your controller below.
// The IP address will be dependent on your local network:
byte mac[] = {
0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; 
IPAddress ip(192,168,0, 42);

// Initialize the Ethernet server library
// with the IP address and port you want to use
// (port 80 is default for HTTP):
EthernetServer server(80);

RTC_DS1307 RTC;

volatile int	gas_counter = 0;
volatile int	ele_counter = 0;

void GasImpulse()
{
	static unsigned long last_interrupt = 0;
	unsigned long time = millis();
	if (time-last_interrupt > 200)
	{
		last_interrupt = time;
		gas_counter++;
	}
}

void EleImpulse()
{
	static unsigned long last_interrupt = 0;
	unsigned long time = millis();
	if (time-last_interrupt > 200)
	{
		last_interrupt = time;
		ele_counter++;
	}
}

void setup()
{
	// Open serial communications and wait for port to open:
	Serial.begin(9600);
	while (!Serial) {
		; // wait for serial port to connect. Needed for Leonardo only
	}
	
	Serial.println("Setup go");
	
	Wire.begin();
	RTC.begin();
			
	attachInterrupt(0, GasImpulse, RISING);
	attachInterrupt(1, EleImpulse, RISING);
	
	/*pinMode(2, INPUT);
	pinMode(13, OUTPUT);
	digitalWrite(2, HIGH);    // Enable pullup resistor
	//sei();                    // Enable global interrupts
	EIMSK |= (1 << INT0);     // Enable external interrupt INT0
	EICRA |= (1 << ISC01);    // Trigger INT0 on falling edge*/
	
	//Serial.println("b");
	
	
	 // start the Ethernet connection and the server:
	 Ethernet.begin(mac, ip);
	 server.begin();
	 Serial.print("server is at ");
	 Serial.println(Ethernet.localIP());

	/*Serial.print("Initializing SD card...");
	// make sure that the default chip select pin is set to
	// output, even if you don't use it:
	pinMode(10, OUTPUT);
	
	// see if the card is present and can be initialized:
	if (!SD.begin(chipSelect)) {
		Serial.println("Card failed, or not present");
		// don't do anything more:
		return;
	}
	Serial.println("card initialized.");*/
}



/*
void sdstuff()
{
	// make a string for assembling the data to log:
	String dataString = "";

	// read three sensors and append to the string:
	for (int analogPin = 0; analogPin < 3; analogPin++) {
		int sensor = analogRead(analogPin);
		dataString += String(sensor);
		if (analogPin < 2) {
			dataString += ",";
		}
	}

	// open the file. note that only one file can be open at a time,
	// so you have to close this one before opening another.
	File dataFile = SD.open("datalog.txt", FILE_WRITE);

	// if the file is available, write to it:
	if (dataFile) {
		dataFile.println(dataString);
		dataFile.close();
		// print to the serial port too:
		Serial.println(dataString);
	}
	// if the file isn't open, pop up an error:
	else {
		Serial.println("error opening datalog.txt");
	}
}
*/
void rtcstuff()
{
	    DateTime now = RTC.now();
	    
	    Serial.print(now.year(), DEC);
	    Serial.print('/');
	    Serial.print(now.month(), DEC);
	    Serial.print('/');
	    Serial.print(now.day(), DEC);
	    Serial.print(' ');
	    Serial.print(now.hour(), DEC);
	    Serial.print(':');
	    Serial.print(now.minute(), DEC);
	    Serial.print(':');
	    Serial.print(now.second(), DEC);
		Serial.print(" = ");
		Serial.print(gas_counter);
	    Serial.println();

	    delay(3000);
}

void loop()
{

	//rtcstuff();
	
	// listen for incoming clients
	EthernetClient client = server.available();
	if (client) {
		Serial.println("new client");
		// an http request ends with a blank line
		boolean currentLineIsBlank = true;
		while (client.connected()) {
			if (client.available()) {
				char c = client.read();
				Serial.write(c);
				// if you've gotten to the end of the line (received a newline
				// character) and the line is blank, the http request has ended,
				// so you can send a reply
				if (c == '\n' && currentLineIsBlank) {
					// send a standard http response header
					client.println("HTTP/1.1 200 OK");
					client.println("Content-Type: text/html");
					client.println("Connnection: close");
					client.println();
					client.println("<!DOCTYPE HTML>");
					client.println("<html>");
					// add a meta refresh tag, so the browser pulls again every 5 seconds:
					//client.println("<meta http-equiv=\"refresh\" content=\"5\">");
					// output the value of each analog input pin
					/*for (int analogChannel = 0; analogChannel < 6; analogChannel++) {
						int sensorReading = analogRead(analogChannel);
						client.print("analog input ");
						client.print(analogChannel);
						client.print(" is ");
						client.print(sensorReading);
						client.println("<br />");
					}*/
					client.print("Gas Counter = "); client.print(gas_counter);
					client.print("<br>Ele Counter = "); client.print(ele_counter);
					client.println("</html>");
					break;
				}
				if (c == '\n') {
					// you're starting a new line
					currentLineIsBlank = true;
				}
				else if (c != '\r') {
					// you've gotten a character on the current line
					currentLineIsBlank = false;
				}
			}
		}
		// give the web browser time to receive the data
		delay(1);
		// close the connection:
		client.stop();
		Serial.println("client disonnected");
	}
	
}

